package handlers

import (
	"database/sql"
	"encoding/json"
	"io"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/hiteshVasisht99/excel-import/common"
	"github.com/hiteshVasisht99/excel-import/employeeDao"
	"github.com/hiteshVasisht99/excel-import/models"
	"github.com/hiteshVasisht99/excel-import/services"
	"github.com/redis/go-redis/v9"
)

var svc services.EmployeeService

func InitializeService(Db *sql.DB, rdb *redis.Client) {
	svc = services.EmployeeService{
		Dao: employeeDao.EmployeeDao{
			Db:  Db,
			Rdb: rdb,
		},
	}
}

func UploadFile(w http.ResponseWriter, r *http.Request) {

	//retrieves the file from the form data with the key "file"
	file, _, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "Unable to process file", http.StatusBadRequest)
		return
	}
	defer file.Close()

	//Create a temporary file to save the uploaded file. something like upload-abc123.xlsx, where abc123 is a unique identifier generated by OS
	tempFile, err := os.CreateTemp("", "upload-*.xlsx")
	if err != nil {
		http.Error(w, "Unable to create temp file", http.StatusInternalServerError)
		return
	}
	defer tempFile.Close()

	//Copy the contents of the uploaded file to the temporary file.
	_, err = io.Copy(tempFile, file)
	if err != nil {
		http.Error(w, "Unable to save file", http.StatusInternalServerError)
		return
	}

	records, err := common.ParseExcelFile(tempFile.Name())
	if err != nil {
		http.Error(w, "Unable to parse file", http.StatusInternalServerError)
		return
	}
	//we are not waiting here for data to get uploaded, If there is any error while uploading we will log it , and can send it to any kafka-topic to inform consumer
	go func() {
		for _, record := range records {
			record.ID = uuid.NewString()
			err = svc.InsertRecord(record)
			if err != nil {
				log.Println("failed to upload record", record)
				return
			}
		}
	}()

	w.WriteHeader(http.StatusAccepted)
	response := map[string]string{"message": "Employee data upload started.."}
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, "Error while encoding the response", http.StatusInternalServerError)
	}
}

func GetEmployeeDataByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	empID := mux.Vars(r)["id"]

	employee, err := svc.FindEmployee(empID)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	err = json.NewEncoder(w).Encode(employee)
	if err != nil {
		http.Error(w, "error while encoding the response", http.StatusInternalServerError)
		return
	}

}

func UpdateEmployeeDataByID(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Extract the employee ID from the URL parameters
	empID := mux.Vars(r)["id"]

	// Parse the request body into an Employee object
	var employee models.Employee
	if err := json.NewDecoder(r.Body).Decode(&employee); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Set the ID from the URL parameter
	employee.ID = empID

	// Update the employee record in the database
	err := svc.UpdateEmployeeByID(&employee)
	if err != nil {
		if strings.Contains(err.Error(), "no employee found") {
			http.Error(w, err.Error(), http.StatusNotFound)
			return
		}
		http.Error(w, "Error updating employee", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	response := map[string]string{"message": "Employee updated successfully"}
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, "Error while encoding the response", http.StatusInternalServerError)
	}
}
